#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <iomanip>
#include "Riostream.h"
#include <vector>
#include <signal.h>
#include <cmath>
#include <iostream>
#include <string>
#include <fstream>
#include <arpa/inet.h>
#include <map>
#include <ncurses.h>

#include "TROOT.h"
#include "TFile.h"
#include "TTree.h"
#include "TBranch.h"

using namespace std;


#define CFD_INT_LEN 4
#define CFD_DELAY 4
#define CFD_FRACTION 4
#define AVG_TR_LENGTH 108
#define AVG_TR_STRIDE 110
#define TR_SCALE 10000

#define NUM_CHAN 40

#define DEBUG 0

/* Utility functions for interrupting the sort cleanly, and for terminal progress bar. */

Int_t gotSignal;
void breakhandler(int dummy) {
  cout << "Got break signal.  Aborting cleanly..." << endl;
  gotSignal = 1;
}

void progressB(int pct) {
  string bar;
  struct winsize uk;
  if (ioctl(0, TIOCGWINSZ, &uk) != 0) {
    exit(1);
  }
  int wdt = uk.ws_col - 20;
  if (wdt < 5) { wdt = 5; }
  for (int i=0; i<wdt; i++) {
    if (i<(pct*wdt/100)) {
      bar.replace(i, 1, "=");
    } else if (i==(pct*wdt/100)) {
      bar.replace(i, 1, ">");
    } else {
      bar.replace(i, 1, " ");
    }
  }
  cout << "\r";
  cout << "[" << bar << "] "; 
  cout .width(3);
  cout << pct << "% complete" << flush;
}

/* GRETA Data Structures */

struct routingHdr {
  uint8_t version;   /* protocol version */
  uint8_t flags;     /* for future use, e.g. debugging */
  uint8_t type;      /* [0..4] ge waveform, scalar digest */
  uint8_t subtype;   /* message sub-type, e.g. crystal ID for waveform messages */
  uint16_t length;   /* length of payload */
  uint16_t seqnum;   /* sequence number */
  int64_t timestamp; /* generated by trigger (10ns clock) */
  int64_t checksum;  /* integrity checksum */
};

struct gretaWaveformMsg {
  /* This is coming from the Google document: 
     Interface/Specifications: Filter Board to Forward Buffer
     Format taken on Nov. 15 / 2019  -  HLC                     */
  uint8_t  version;    /* protocol version = 0x1 for prototype waveform version */
  uint8_t  id;         /* crystal id */
  uint16_t tr_len;     /* trace length (in 2-byte words) */
  uint16_t trig_src;   /*info from trigger */
  uint16_t pad;        /* pad to 8-byte alignment */
  int64_t  timestamp;  /* timestamp of first sample */
  int32_t  ener[NUM_CHAN];   /* energy given by filter 1 */
  uint64_t pileup;           /* pileup flags for filter 1 */
  int16_t  hist_corr[2][2];  /* energy/time pairs of preceeding 2 events */
  int16_t  t0;           /* time offset for decomp (if available) */
  int16_t  sub_t0;       /* sub-tick time for decomp (if available) */
  int16_t  t_led_core;   /* time offset for core LED */
  int16_t  t_cfd_core;   /* time offset for core CFD */
  int16_t  t_led_first;  /* time offset for LED of first hit */
  int16_t  t_postpileup; /* time offset for post pileup */
  int16_t  t_ovfl;       /* time offset since last overflow */
  int16_t  t_rst;        /* time offset since last reset */
  int16_t  tr[NUM_CHAN][512];  /* waveforms */
};

/* Function for 64-bit numbers endian-ness stuff */
uint64_t ntoh64(uint64_t input) {
  uint64_t rval;
  printf("%x -- ", input);
  uint8_t *data = (uint8_t *)&rval;
  data[0] = input >> 56;
  data[1] = input >> 48;
  data[2] = input >> 40;
  data[3] = input >> 32;
  data[4] = input >> 24;
  data[5] = input >> 16;
  data[6] = input >> 8;
  data[7] = input >> 0;
  printf("%x\n", rval);
  return rval;
}

uint64_t hton64(uint64_t input) {
  return (ntoh64(input));
}




int main (int argc, char *argv[]) {
  
  /* Some CTRL-C interrupt handling stuff... */
  gotSignal = 0;
  signal(SIGINT, breakhandler);

  if (argc < 3) {
    printf("Usage: readGreta <InputFileWithPath> <ROOTOutputName>");
  }

  routingHdr rHeader;
  gretaWaveformMsg wform;

  float ccEnergy[4];
  float segEnergy[36];
  float bl[40];
  vector<float> pz;
  float sumA = 0.; float sumB = 0.;
  int16_t trReOrder[NUM_CHAN][512]; 
  //float gain[40] = {0.005003, 0.004585, 0.005135, 0.005055, 0.005026,
  //		    0.004568, 0.004223, 0.004837, 0.005004, 0.005054, 
  //		    0.004899, 0.005106, 0.005076, 0.004879, 0.004870,
  //		    0.004885, 0.004839, 0.004980, 0.004993, 0.005072,
  //		    0.005138, 0.004981, 0.004932, 0.004523, 0.004814,
  //		    0.005209, 0.004951, 0.005020, 0.004985, 0.004504,
  //		    0.004846, 0.004790, 0.005008, 0.000000, 0.000000,
  //		    0.005031, 0.003559, 0.000761, 0.001460, 0.011390};
  float gain[40] = {0.001031, 0.001029, 0.000973, 0.001004, 0.001016,
		    0.001001, 0.001052, 0.001015, 0.001001, 0.001031,
		    0.001021, 0.001016, 0.001015, 0.000936, 0.001010, 
		    0.000943, 0.000776, 0.001016, 0.000995, 0.001030, 
		    0.000992, 0.001026, 0.001007, 0.000997, 0.001010, 
		    0.001011, 0.000986, 0.000963, 0.001023, 0.001015, 
		    0.001004, 0.001035, 0.001011, 0.001036, 0.001043, 
		    0.000973, 0.003532, 0.000755, 0.001450, 0.011291};
  int mult = 0;
  float cfdTime = -1.;
  int data4net[36] = {0};
  float averageTrace[40][4096];
  int averageTraceINT[40][4096];
  float traceGain[40] = {0.0};

  std::map<int, int> segMap; /* Seg#, ADC# */
  segMap.insert(std::pair<int, int>(29, 0));   segMap.insert(std::pair<int, int>(23, 1));
  segMap.insert(std::pair<int, int>(35, 2));   segMap.insert(std::pair<int, int>(11, 3));
  segMap.insert(std::pair<int, int>(5, 4));    segMap.insert(std::pair<int, int>(24, 5));
  segMap.insert(std::pair<int, int>(16, 6));   segMap.insert(std::pair<int, int>(9, 7));
  segMap.insert(std::pair<int, int>(3, 8));    segMap.insert(std::pair<int, int>(33, 9));
  segMap.insert(std::pair<int, int>(15, 10));  segMap.insert(std::pair<int, int>(27, 11));
  segMap.insert(std::pair<int, int>(17, 12));  segMap.insert(std::pair<int, int>(10, 13));
  segMap.insert(std::pair<int, int>(4, 14));   segMap.insert(std::pair<int, int>(34, 15));
  segMap.insert(std::pair<int, int>(28, 16));  segMap.insert(std::pair<int, int>(22, 17));
  segMap.insert(std::pair<int, int>(25, 18));  segMap.insert(std::pair<int, int>(19, 19));
  segMap.insert(std::pair<int, int>(20, 20));  segMap.insert(std::pair<int, int>(32, 21));
  segMap.insert(std::pair<int, int>(2, 22));   segMap.insert(std::pair<int, int>(21, 23));
  segMap.insert(std::pair<int, int>(12, 24));  segMap.insert(std::pair<int, int>(18, 25));
  segMap.insert(std::pair<int, int>(6, 26));   segMap.insert(std::pair<int, int>(0, 27));
  segMap.insert(std::pair<int, int>(30, 28));  segMap.insert(std::pair<int, int>(31, 29));
  segMap.insert(std::pair<int, int>(13, 30));  segMap.insert(std::pair<int, int>(7, 31));
  segMap.insert(std::pair<int, int>(1, 32));   segMap.insert(std::pair<int, int>(26, 33));
  segMap.insert(std::pair<int, int>(14, 34));  segMap.insert(std::pair<int, int>(8, 35));
  segMap.insert(std::pair<int, int>(36, 36));  segMap.insert(std::pair<int, int>(37, 37));
  segMap.insert(std::pair<int, int>(38, 38));  segMap.insert(std::pair<int, int>(39, 39));

  /* Initialize ROOT output */
  TFile *fOut = new TFile(argv[2], "RECREATE");
  TTree *data = new TTree("data", "data");
  
  data->Branch("version", &(wform.version), "version/b");
  data->Branch("id", &(wform.id), "id/b");
  data->Branch("trLength", &(wform.tr_len), "trLength/s");
  // data->Branch("trigSrc", &(wform.trig_src), "trigSrc/s");
  // data->Branch("pad", &(wform.pad), "pad/s");
  data->Branch("ener", &(wform.ener), "ener[40]/I");
  data->Branch("trace", &(wform.tr), "trace[40][512]/S");
  // data->Branch("trace", &(trReOrder), "trace[40][512]/S");
  data->Branch("seqNum", &(rHeader.seqnum), "seqNum/s");
  // data->Branch("ccEnergy", &ccEnergy, "ccEnergy[4]/F");
  // data->Branch("segEnergy", &segEnergy, "segEnergy[36]/F");
  data->Branch("baseline", &bl, "baseline[40]/F");
  data->Branch("TS", &(rHeader.timestamp), "TS/L");
  // data->Branch("cfdTimeCC", &cfdTime, "cfdTimeCC/F");
  // data->Branch("mult", &mult, "mult/I");
  
  unsigned char buf[65536];
  UShort_t junk[8192];

  /* Check file length for progress */
  struct stat fileStatus;
  stat(argv[1], &fileStatus);
  int64_t bytesInFile = (int64_t) fileStatus.st_size;

  cout << "Input data file size is " << bytesInFile/1024/1024/1024 << " GB\n\n";
  
  int64_t bytesRead = 0;

  FILE *inf;
  inf = fopen(argv[1], "r");

  Int_t siz = 0;
  siz = fread(&buf, sizeof(struct routingHdr), 1, inf);
  bytesRead += sizeof(struct routingHdr);
  unsigned char *tmp = (buf);
  memmove(&rHeader, tmp, sizeof(struct routingHdr));

  while (siz && !gotSignal) {
    rHeader.seqnum = ntohs(rHeader.seqnum);
    rHeader.timestamp = (int64_t)ntoh64((uint64_t)rHeader.timestamp);
    
    if (DEBUG) {
      printf("Routing Header: \n");
      printf("    Version:  0x%x\n", rHeader.version);
      printf("    Flags:    %i\n", rHeader.flags);
      printf("    Type:     %i\n", rHeader.type);
      printf("    SubType:  %i\n", rHeader.subtype);
      printf("    Length:   %i\n", ntohs(rHeader.length));
      printf("    SeqNum:   %i\n", rHeader.seqnum);
      printf("    TS:       %i\n", rHeader.timestamp);
      printf("    Checksum: %i\n", ntohs(rHeader.checksum));
      cin.get();
    } 
    
    if (rHeader.type == 3) {
      siz = fread(&buf, 1, ntohs(rHeader.length), inf);
      bytesRead += ntohs(rHeader.length);
      tmp = (buf);
      memmove(&wform, tmp, sizeof(struct gretaWaveformMsg));
      
      wform.tr_len = ntohs(wform.tr_len);
      wform.trig_src = ntohs(wform.trig_src);
      wform.pad = ntohs(wform.pad);
      mult = 0;
      for (int i=0; i<NUM_CHAN; i++) {
	wform.ener[i] = ntohl(wform.ener[i]);

	float blsum = 0.0;
	for (int j=0; j<512; j++) {
	  if (wform.tr[i][j] == -320) { wform.tr[i][j] = 0.0; }
	  wform.tr[i][j] = ntohs(wform.tr[i][j]);
	  if (i >= 36) { wform.tr[i][j] *= -1; }
	  if (j<20) { 
	    blsum += (float)(wform.tr[i][j]);
	  }
	}
	bl[i] = blsum/20.;
	
	if (0) {	
	  //float ipz = 0;
	  //float tau =1./ 5100.;
	  float base = 0.0;
	  //sumA = 0.; sumB = 0.;
	  for (int j=0; j<30; j++) {
	    base += wform.tr[i][10+j];
	  }
	  base /= 30.;
	  //pz.clear();
	  //for (int j=50; j<wform.tr_len; j++) {
	  // pz.push_back(wform.tr[i][j] - base + ipz*tau);
	  // ipz += wform.tr[i][j] - base;
	  //}
	  //for (int j=10; j<100; j++) {
	  // sumA += pz[j];
	  //sumA += pz[j+90];//for 356-156 trace window
	  //}
	  //for (int j=0; j<100; j++) {
	  // sumB += pz[pz.size()-150-j];
	  //sumB += pz[pz.size()-10-j]; // for 356-156 trace window
	  //}
	  //if (i >= 36) {
	  // ccEnergy[i-36] = (sumB - sumA)*gain[i];
	  //} else {
	  // segEnergy[i] = (sumB - sumA)*gain[i];
	  // if (segEnergy[i] > 30.) { mult++; }
	  //}
	  
	  if (i<36) {
	    segEnergy[i] = (float)wform.ener[i]*gain[i];
	    if (segEnergy[i] > 30) { mult++; }
	  } else {
	    ccEnergy[i-36] = (float)wform.ener[i]*gain[i];
	  }
	  
	  
	  for (int j=0; j<wform.tr_len; j++) {
	    wform.tr[i][j] -= (int16_t)base;
	  }  
	}
      }

      if (0) {
	for (int i=0; i<NUM_CHAN; i++) {
	  for (int j=0; j<wform.tr_len; j++) {
	    trReOrder[i][j] = wform.tr[segMap.find(i)->second][j];
	  }
	}
	
	if (mult==1) {
	  cfdTime = 0.0;
	  for (int ch=0; ch<36; ch++) {
	    if (segEnergy[ch] >= 1330 && segEnergy[ch] <= 1334 &&
		ccEnergy[0] >= 1330 && ccEnergy[0] <= 1334) {
	      /* Time alignment! */
	      Int_t deriv[1024];
	      Int_t cfd[1024];
	      Int_t imax = 0, max_deriv = 0;
	      deriv[0] = 0;
	      for (int j=0; j<CFD_INT_LEN; j++) {
		deriv[0] += (wform.tr[36][j+CFD_INT_LEN] -  wform.tr[36][j]);
	      }
	      for (int j=1; j<wform.tr_len - 5 - 2*CFD_INT_LEN; j++) {
		deriv[j] = (deriv[j-1] + 
			    wform.tr[36][j+2*CFD_INT_LEN] -
			    2*wform.tr[36][j+CFD_INT_LEN] + 
			    wform.tr[36][j]);
		if (max_deriv < deriv[j]) {
		  max_deriv = deriv[j];
		  imax = j;
		}
	      }
	      for (int j=0; j<wform.tr_len - 5 - 2*CFD_INT_LEN - CFD_DELAY; j++) {
		cfd[j] = deriv[j] - deriv[j+CFD_DELAY]/CFD_FRACTION;
	      }
	      for (int j=imax + CFD_DELAY; j>0; j--) {
		if (cfd[j] <=0 && cfd[j+1] > 0) {
		  cfdTime = ((float)j) - ((float)cfd[j])/((float)(cfd[j+1]-cfd[j]));
		  break; 
		}
	      }
	      
	      if (cfdTime > 0) { 
		/* This data set is centered with tCFD = 65 */
		int delay = (int)(cfdTime + 0.5) - 16;
		delay -= (65-16);
		
		/* Shift traces */
		if (delay < 0) {
		  for (int j=0; j<40; j++) {
		    for (int k=wform.tr_len-2; k > (0-delay); k--) {
		      wform.tr[j][k] = wform.tr[j][k+delay];
		    }
		    for (int k=0; k < (0-delay); k++) {
		      wform.tr[j][k] = 0;
		    }
		  }
		} else {
		  for (int j=0; j<40; j++) {
		    for (int k=0; k<=wform.tr_len-delay-2; k++) {
		      wform.tr[j][k] = wform.tr[j][k+delay];
		    }
		    for (int k=wform.tr_len-delay-1; k < wform.tr_len; k++) {
		      wform.tr[j][k] = wform.tr[j][wform.tr_len-2];
		    }
		  }
		}
		
		data4net[ch]++;
		int whichToFill = -1;
		for (int j=0; j<36; j++) { if (segMap.find(j)->second == ch) { whichToFill = segMap.find(j)->first; } }
		for (int j=0; j<37; j++) {
		  for (int m=0; m<AVG_TR_LENGTH; m++) {
		    
		    averageTrace[whichToFill][j*(AVG_TR_STRIDE)+m] += (float)wform.tr[segMap.find(j)->second][m+65];
		    //printf("For seg %d, using trace %d\n", j, segMap.find(j)->second);
		  }
		}
	      }
	    }
	  }
	}
      }
      
      if (DEBUG) {
	printf("Waveform message!\n");
	printf("  Version:  %i\n", wform.version);
	printf("  ID:           %i\n", wform.id);
	printf("  tr_len:      %i\n", wform.tr_len);
	printf("  trig_src:   %i\n", wform.trig_src);
	printf("  pad:         %i\n", wform.pad);
	printf("  timestamp: %i\n", (int64_t)ntoh64((uint64_t)wform.timestamp));
	for (int i=0; i<40; i++) {
	  printf("  Raw energy %d: %d\n", i, wform.ener[i]);
	}
	cin.get();
      }
      
      /* Fill tree... */
      data->Fill();
      
    } else {
      siz = fread(&buf, 1, ntohs(rHeader.length), inf);
      bytesRead += ntohs(rHeader.length);
      if (siz != ntohs(rHeader.length)) {
	cout << "SkipData(): Failed.\n";
	cout << endl;
      }
    }
    
    progressB(100*bytesRead/bytesInFile);
    
    siz = fread(&rHeader, sizeof(struct routingHdr), 1, inf);
    bytesRead += sizeof(struct routingHdr);
  }

  if (0) {
    for (int j=0; j<36; j++) {
      traceGain[j] = (((float)averageTrace[j][j*AVG_TR_STRIDE + AVG_TR_LENGTH-1]) /
		      ((float)averageTrace[j][36*AVG_TR_STRIDE + AVG_TR_LENGTH - 1]));
      printf("Trace gain %d = %f\n", j, traceGain[j]);
    }
    traceGain[36] = 1.0f;
    for (int j=0; j<36; j++) {
      Float_t scaleFactor = (float)TR_SCALE / ((float)averageTrace[j][36*AVG_TR_STRIDE + AVG_TR_LENGTH-1]);
      for (int k=0; k<37; k++) {
	for (int m=0; m<AVG_TR_LENGTH; m++) {
	  averageTrace[j][k*AVG_TR_STRIDE + m] = ((float)averageTrace[j][k*AVG_TR_STRIDE + m])*scaleFactor / traceGain[k];
	  averageTraceINT[j][k*AVG_TR_STRIDE + m] = (int)averageTrace[j][k*AVG_TR_STRIDE + m];
	}
      }
    }
    if (data4net[0] > 0 || data4net[1] > 0) {
      char filenameOut[1024];
      sprintf(filenameOut, "SPGRETA_1332.spn");
      cout << "Writing superpulses to " << filenameOut << endl;
      
      FILE *spOut = fopen(filenameOut, "wb");
      for (Int_t j=0; j<36; j++) {
	fwrite(averageTraceINT[j], sizeof(Int_t), 4096, spOut);
      }
      fclose(spOut);
      printf("Superpulse statistics:\n");
      for (Int_t k=0; k<36; k++) {
	printf("%d -- %d\n", k, data4net[k]);
      }
    }
  }
  
  data->Write();
  fOut->Write();
  fOut->Close();
  printf("\nDone and done.\n\n");
  
  return 0;
}
