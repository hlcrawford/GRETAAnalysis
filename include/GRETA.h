#ifndef __GRETA_H
#define __GRETA _H

#include "Riostream.h"
#include "Rtypes.h"

#include "TObject.h"
#include "TString.h"
#include "TVector3.h"
#include "TClass.h"

#include <vector>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <arpa/inet.h>

#include "colors.h"

using std::vector;
using std::cout;  using std::endl;
using std::swap;

#define NUM_CHAN 40

/* GRETA Data Structures */

struct routingHdr {
  uint8_t version;   /* protocol version */
  uint8_t flags;     /* for future use, e.g. debugging */
  uint8_t type;      /* [0..4] ge waveform, scalar digest */
  uint8_t subtype;   /* message sub-type, e.g. crystal ID for waveform messages */
  uint16_t length;   /* length of payload */
  uint16_t seqnum;   /* sequence number */
  int64_t timestamp; /* generated by trigger (10ns clock) */
  int64_t checksum;  /* integrity checksum */
};

struct gretaWaveformMsg {
  /* This is coming from the Google document: 
     Interface/Specifications: Filter Board to Forward Buffer
     Format taken on Nov. 15 / 2019  -  HLC                     */
  uint8_t  version;    /* protocol version = 0x1 for prototype waveform version */
  uint8_t  id;         /* crystal id */
  uint16_t tr_len;     /* trace length (in 2-byte words) */
  uint16_t trig_src;   /*info from trigger */
  uint16_t pad;        /* pad to 8-byte alignment */
  int64_t  timestamp;  /* timestamp of first sample */
  uint64_t pileup;           /* pileup flags for filter 1 */
  int16_t  hist_corr[2][2];  /* energy/time pairs of preceeding 2 events */
  int16_t  t0;           /* time offset for decomp (if available) */
  int16_t  sub_t0;       /* sub-tick time for decomp (if available) */
  int16_t  t_led_core;   /* time offset for core LED */
  int16_t  t_cfd_core;   /* time offset for core CFD */
  int16_t  t_led_first;  /* time offset for LED of first hit */
  int16_t  t_postpileup; /* time offset for post pileup */
  int16_t  t_ovfl;       /* time offset since last overflow */
  int16_t  t_rst;        /* time offset since last reset */
  int32_t  ener[NUM_CHAN];   /* energy given by filter 1 */
  int16_t  tr[NUM_CHAN][512];  /* waveforms */
};

class g3CrystalEvent : public TObject {
 public:
  uint16_t rhSequence;
  int64_t  rhTS; /* generated by trigger (10ns clock) */
  uint8_t  rhSubType;
  uint8_t  version;    /* protocol version = 0x1 for prototype waveform version */
  uint8_t  id;         /* crystal id */
  uint16_t trLen;     /* trace length (in 2-byte words) */
  uint16_t trigSrc;   /*info from trigger */
  uint16_t pad;        /* pad to 8-byte alignment */
  int64_t   timestamp;  /* timestamp of first sample */
  uint64_t pileup;           /* pileup flags for filter 1 */
  int16_t  hist_corr[2][2];  /* energy/time pairs of preceeding 2 events */
  int16_t  t0;           /* time offset for decomp (if available) */
  int16_t  subt0;       /* sub-tick time for decomp (if available) */
  int16_t  tLEDCore;   /* time offset for core LED */
  int16_t  tCFDCore;   /* time offset for core CFD */
  int16_t  tLEDFirst;  /* time offset for LED of first hit */
  int16_t  tPostpileup; /* time offset for post pileup */
  int16_t  tOvfl;       /* time offset since last overflow */
  int16_t  tRst;        /* time offset since last reset */
  int32_t  ener[NUM_CHAN];   /* energy given by filter 1 */
  int16_t  tr[NUM_CHAN][512];  /* waveforms */
  int32_t  ccE[4];
  int32_t  segE[36];

 public:
  g3CrystalEvent() { ; }
  ~g3CrystalEvent() { ; }
  void Clear();

 private:
  ClassDef(g3CrystalEvent, 1);
};

class g3OUT : public TObject {
 public:
  vector<g3CrystalEvent> xtals;

 public:
  g3OUT() { ; }
  ~g3OUT() { ; }
  void Reset();
  UInt_t crystalMult();
  Float_t calorimeterE();

 private:
  ClassDef(g3OUT, 1);
};

class GRETA : public TObject {
 public:
  g3CrystalEvent g3X;
  unsigned char gBuf[32*32*1024];

  g3OUT g3Out;

  std::map<int, int> segMap;
  Float_t gain[120][40];
  Float_t offset[120][40];

 public:
  GRETA() { ; }
  ~GRETA() { ; }
  void Initialize();
  void Reset();
  Int_t getMode3(FILE *inf, Int_t evtLength, Int_t subType);
  Int_t analyzeMode3(g3CrystalEvent *g3);
  uint64_t ntoh64(uint64_t input);
  uint64_t hton64(uint64_t input);
  
 public:
  ClassDef(GRETA, 1);
};

#endif
